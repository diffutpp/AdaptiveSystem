# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13pI5u6KVBVqdRjNS4ly8xC-v6cIB_YbW
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from IPython.display import HTML  # Colabでの表示に必要

# --- パラメータ設定 ---

NUM_BOIDS = 50       # Boidの数
WORLD_SIZE = [200.0, 200.0]  # シミュレーション空間のサイズ [width, height]
MAX_SPEED = 3.0      # Boidの最大速度
MAX_FORCE = 0.5      # Boidに加わる力の最大値（加速度の制限）

# BOIDルールのパラメータ
PERCEPTION_RADIUS = 25.0  # 他のBoidを認識する範囲
SEPARATION_DISTANCE = 10.0 # これ以上近づくと「分離」が強く働く距離

# 各ルールの重み
COHESION_WEIGHT = 1.0     # 結合 (群れの中心へ)
ALIGNMENT_WEIGHT = 1.0    # 整列 (平均的な進行方向へ)
SEPARATION_WEIGHT = 1.5   # 分離 (近づきすぎない)

# 境界処理用のマージン
EDGE_MARGIN = 5.0
EDGE_TURN_FORCE = 1.0     # 境界でUターンする力

# --- Boidクラスの定義 ---

class Boid:
    def __init__(self, x, y):
        self.position = np.array([x, y], dtype=float)
        # ランダムな初期速度
        angle = np.random.uniform(0, 2 * np.pi)
        self.velocity = np.array([np.cos(angle), np.sin(angle)], dtype=float) * MAX_SPEED
        self.acceleration = np.zeros(2, dtype=float)

    def update(self):
        """ 位置と速度を更新する """
        self.velocity += self.acceleration
        # 速度制限
        speed = np.linalg.norm(self.velocity)
        if speed > MAX_SPEED:
            self.velocity = (self.velocity / speed) * MAX_SPEED

        self.position += self.velocity

        # 加速度をリセット (次のフレームで再計算するため)
        self.acceleration = np.zeros(2, dtype=float)

    def apply_force(self, force):
        """ 力を適用する (加速度に加算) """
        self.acceleration += force

    def limit_force(self, steering):
        """ ステアリング（操舵）の力を制限する """
        mag = np.linalg.norm(steering)
        if mag > MAX_FORCE:
            steering = (steering / mag) * MAX_FORCE
        return steering

    def avoid_edges(self):
        """ 画面の端でUターンする処理 """
        steer = np.zeros(2, dtype=float)
        if self.position[0] < EDGE_MARGIN:
            steer[0] = EDGE_TURN_FORCE
        elif self.position[0] > WORLD_SIZE[0] - EDGE_MARGIN:
            steer[0] = -EDGE_TURN_FORCE

        if self.position[1] < EDGE_MARGIN:
            steer[1] = EDGE_TURN_FORCE
        elif self.position[1] > WORLD_SIZE[1] - EDGE_MARGIN:
            steer[1] = -EDGE_TURN_FORCE

        return steer

    def apply_boid_rules(self, boids):
        """ BOIDの3ルール（分離・整列・結合）を計算・適用する """

        separation_force = np.zeros(2, dtype=float)
        alignment_force = np.zeros(2, dtype=float)
        cohesion_force = np.zeros(2, dtype=float)

        total_separation = 0
        total_alignment = 0
        total_cohesion = 0

        # 周囲のBoidをスキャン
        for other in boids:
            if other == self:
                continue

            dist = np.linalg.norm(self.position - other.position)

            # 認識範囲内のBoidのみを対象
            if 0 < dist < PERCEPTION_RADIUS:
                # 1. 分離 (Separation)
                if dist < SEPARATION_DISTANCE:
                    diff = self.position - other.position
                    # 距離が近いほど強く反発する
                    separation_force += diff / (dist * dist)
                    total_separation += 1

                # 2. 整列 (Alignment)
                alignment_force += other.velocity
                total_alignment += 1

                # 3. 結合 (Cohesion)
                cohesion_force += other.position
                total_cohesion += 1

        # --- 各ルールの力を計算 ---

        # 1. 分離 (Separation)
        if total_separation > 0:
            separation_force /= total_separation
            if np.linalg.norm(separation_force) > 0:
                separation_force = (separation_force / np.linalg.norm(separation_force)) * MAX_SPEED
            steering_sep = self.limit_force(separation_force - self.velocity)
        else:
            steering_sep = np.zeros(2, dtype=float)

        # 2. 整列 (Alignment)
        if total_alignment > 0:
            alignment_force /= total_alignment
            if np.linalg.norm(alignment_force) > 0:
                alignment_force = (alignment_force / np.linalg.norm(alignment_force)) * MAX_SPEED
            steering_align = self.limit_force(alignment_force - self.velocity)
        else:
            steering_align = np.zeros(2, dtype=float)

        # 3. 結合 (Cohesion)
        if total_cohesion > 0:
            cohesion_force /= total_cohesion
            direction_to_center = cohesion_force - self.position
            if np.linalg.norm(direction_to_center) > 0:
                direction_to_center = (direction_to_center / np.linalg.norm(direction_to_center)) * MAX_SPEED
            steering_cohesion = self.limit_force(direction_to_center - self.velocity)
        else:
            steering_cohesion = np.zeros(2, dtype=float)

        # 境界回避の力を計算
        steering_edges = self.avoid_edges()

        # 各ルールに重みを付けて力を適用
        self.apply_force(steering_sep * SEPARATION_WEIGHT)
        self.apply_force(steering_align * ALIGNMENT_WEIGHT)
        self.apply_force(steering_cohesion * COHESION_WEIGHT)
        self.apply_force(steering_edges * 1.5)

# --- シミュレーションのセットアップ ---

# 実行のたびに初期位置が変わるよう、シードをリセット
np.random.seed(None)

# Boidのリストを初期化
boids = [
    Boid(
        np.random.uniform(EDGE_MARGIN, WORLD_SIZE[0] - EDGE_MARGIN),
        np.random.uniform(EDGE_MARGIN, WORLD_SIZE[1] - EDGE_MARGIN)
    )
    for _ in range(NUM_BOIDS)
]

# Matplotlibの描画設定
fig, ax = plt.subplots(figsize=(10, 10))
ax.set_xlim(0, WORLD_SIZE[0])
ax.set_ylim(0, WORLD_SIZE[1])
ax.set_aspect('equal')
ax.axes.xaxis.set_visible(False)
ax.axes.yaxis.set_visible(False)

# Boidを描画するための scatter オブジェクト
scatter = ax.scatter([], [], s=10)

# --- アニメーション更新関数 ---

def animate(frame):
    # 1. 各Boidのルールを計算
    for boid in boids:
        boid.apply_boid_rules(boids)

    # 2. 各Boidの位置を更新
    for boid in boids:
        boid.update()

    # 3. 描画データを更新
    positions = np.array([boid.position for boid in boids])
    scatter.set_offsets(positions)

    return scatter,

# --- アニメーションの実行 (Colab用) ---

# frames=400: アニメーションの総再生時間を長くする (200から変更)
# interval=50: フレーム間の待機時間 (50ミリ秒)
ani = animation.FuncAnimation(fig, animate,
                              frames=400,
                              interval=50,
                              blit=True)

print("BOIDシミュレーションを開始します...")
print("アニメーションをHTMLに変換しています...")

# HTMLに変換してColab上に動画として表示
HTML(ani.to_html5_video())

