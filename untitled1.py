# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13pI5u6KVBVqdRjNS4ly8xC-v6cIB_YbW
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from IPython.display import HTML

NUM_BOIDS = 50
WORLD_SIZE = [200.0, 200.0]
MAX_SPEED = 3.0
MAX_FORCE = 0.5

PERCEPTION_RADIUS = 25.0
SEPARATION_DISTANCE = 10.0

COHESION_WEIGHT = 1.0
ALIGNMENT_WEIGHT = 1.0
SEPARATION_WEIGHT = 1.5

EDGE_MARGIN = 5.0
EDGE_TURN_FORCE = 1.0

class Boid:
    def __init__(self, x, y):
        self.position = np.array([x, y], dtype=float)
        angle = np.random.uniform(0, 2 * np.pi)
        self.velocity = np.array([np.cos(angle), np.sin(angle)], dtype=float) * MAX_SPEED
        self.acceleration = np.zeros(2, dtype=float)

    def update(self):
        self.velocity += self.acceleration
        speed = np.linalg.norm(self.velocity)
        if speed > MAX_SPEED:
            self.velocity = (self.velocity / speed) * MAX_SPEED

        self.position += self.velocity
        self.acceleration = np.zeros(2, dtype=float)

    def apply_force(self, force):
        self.acceleration += force

    def limit_force(self, steering):
        mag = np.linalg.norm(steering)
        if mag > MAX_FORCE:
            steering = (steering / mag) * MAX_FORCE
        return steering

    def avoid_edges(self):
        steer = np.zeros(2, dtype=float)
        if self.position[0] < EDGE_MARGIN:
            steer[0] = EDGE_TURN_FORCE
        elif self.position[0] > WORLD_SIZE[0] - EDGE_MARGIN:
            steer[0] = -EDGE_TURN_FORCE

        if self.position[1] < EDGE_MARGIN:
            steer[1] = EDGE_TURN_FORCE
        elif self.position[1] > WORLD_SIZE[1] - EDGE_MARGIN:
            steer[1] = -EDGE_TURN_FORCE

        return steer

    def apply_boid_rules(self, boids):
        separation_force = np.zeros(2, dtype=float)
        alignment_force = np.zeros(2, dtype=float)
        cohesion_force = np.zeros(2, dtype=float)

        total_separation = 0
        total_alignment = 0
        total_cohesion = 0

        for other in boids:
            if other == self:
                continue

            dist = np.linalg.norm(self.position - other.position)

            if 0 < dist < PERCEPTION_RADIUS:
                if dist < SEPARATION_DISTANCE:
                    diff = self.position - other.position
                    separation_force += diff / (dist * dist)
                    total_separation += 1

                alignment_force += other.velocity
                total_alignment += 1

                cohesion_force += other.position
                total_cohesion += 1

        if total_separation > 0:
            separation_force /= total_separation
            if np.linalg.norm(separation_force) > 0:
                separation_force = (separation_force / np.linalg.norm(separation_force)) * MAX_SPEED
            steering_sep = self.limit_force(separation_force - self.velocity)
        else:
            steering_sep = np.zeros(2, dtype=float)

        if total_alignment > 0:
            alignment_force /= total_alignment
            if np.linalg.norm(alignment_force) > 0:
                alignment_force = (alignment_force / np.linalg.norm(alignment_force)) * MAX_SPEED
            steering_align = self.limit_force(alignment_force - self.velocity)
        else:
            steering_align = np.zeros(2, dtype=float)

        if total_cohesion > 0:
            cohesion_force /= total_cohesion
            direction_to_center = cohesion_force - self.position
            if np.linalg.norm(direction_to_center) > 0:
                direction_to_center = (direction_to_center / np.linalg.norm(direction_to_center)) * MAX_SPEED
            steering_cohesion = self.limit_force(direction_to_center - self.velocity)
        else:
            steering_cohesion = np.zeros(2, dtype=float)

        steering_edges = self.avoid_edges()

        self.apply_force(steering_sep * SEPARATION_WEIGHT)
        self.apply_force(steering_align * ALIGNMENT_WEIGHT)
        self.apply_force(steering_cohesion * COHESION_WEIGHT)
        self.apply_force(steering_edges * 1.5)

np.random.seed(None)

boids = [
    Boid(
        np.random.uniform(EDGE_MARGIN, WORLD_SIZE[0] - EDGE_MARGIN),
        np.random.uniform(EDGE_MARGIN, WORLD_SIZE[1] - EDGE_MARGIN)
    )
    for _ in range(NUM_BOIDS)
]

fig, ax = plt.subplots(figsize=(10, 10))
ax.set_xlim(0, WORLD_SIZE[0])
ax.set_ylim(0, WORLD_SIZE[1])
ax.set_aspect('equal')
ax.axes.xaxis.set_visible(False)
ax.axes.yaxis.set_visible(False)

scatter = ax.scatter([], [], s=10)

def animate(frame):
    for boid in boids:
        boid.apply_boid_rules(boids)

    for boid in boids:
        boid.update()

    positions = np.array([boid.position for boid in boids])
    scatter.set_offsets(positions)

    return scatter,

ani = animation.FuncAnimation(fig, animate,
                              frames=400,
                              interval=50,
                              blit=True)


HTML(ani.to_html5_video())

